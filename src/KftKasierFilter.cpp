#include "KftKasierFilter.hpp"

#include <memory>
#include <functional>
#include <iostream>
#include <algorithm>
#include <kfr/base.hpp>
#include <kfr/dsp.hpp>
#include <kfr/io.hpp>

#include "net_relinc_libraries_staticClasses_KftKasierFilter.h"   // auto-generated by `javah HelloJNI`


using namespace kfr;

JNIEXPORT jdoubleArray JNICALL Java_net_relinc_libraries_staticClasses_KftKasierFilter_lowPassFilter
  (JNIEnv *env, jobject obj, jdoubleArray ptr, jdouble filter) {

    jsize len = env->GetArrayLength(ptr);
    jboolean isCopy1;
    jdouble *body = env->GetDoubleArrayElements(ptr, &isCopy1);
    double f_t=filter;

    //Create the vector<double> and reserve enough memory for mapping
    std::vector<double> newvector;
    newvector.reserve(len);

     //Copy the contents of the jdoubleArray to the vector<double>
     for (int i=0; i<len; i++)
     {
        newvector.push_back(body[i]);
     }
          //Release the pointer to the jdoubleArray
     if (isCopy1 == JNI_TRUE)
     {
        env->ReleaseDoubleArrayElements(ptr, body, JNI_ABORT);
     }
    std::vector<double> outputvec = LowPassFilter(newvector,f_t);

    jdoubleArray output = env->NewDoubleArray( outputvec.size() );
    env->SetDoubleArrayRegion( output, 0, outputvec.size(), &outputvec[0] );
    // jdoubleArray output = env->NewDoubleArray(outputvec.size());
    // jboolean isCopy2;
    // jdouble* destArrayElems = env->GetDoubleArrayElements(output, &isCopy2);
    // for (int i=0; i<outputvec.size(); i++)
    // {
    //     destArrayElems[i] = newvector[i];
    // }
    // if (isCopy2 == JNI_TRUE) 
    // {
    //     env->ReleaseDoubleArrayElements(ptr, destArrayElems, 0);
    // }

     return output;

}

std::vector<double> LowPassFilter(std::vector<double> input, double f_t)
{

    univector<double, 0> data(&input[0],input.size());
    univector<double> dest(input.size());
    // for(int idx=0; idx<input.size();idx++)
    //     data[idx]=input[idx];
    int size_taps= 600;
    univector<double> taps(size_taps);
    float kasier_factor = 1.0;

    expression_pointer<fbase> kaiser = to_pointer(window_kaiser(taps.size(), kasier_factor));

   fir_lowpass(taps, f_t, kaiser, true);

    data=fir(data,taps);

    std::vector<double> output(input.size());

    for(int idx=0; idx<input.size();idx++)
        output[idx]=data[idx];

    return output;
}